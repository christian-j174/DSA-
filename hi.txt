public int keepOdd() {
    int counter = 0;
    
    // Start from the end and move to the beginning
    for (int tranversal = this.size() - 1; tranversal >= 0; tranversal--) {
        if ((tranversal % 2) == 0) {
            this.remove(tranversal);
            counter++;
        }
    }

    return counter;
}


		public int replaceAll(E e, E f) {
			int counter = 0;
			
			Node<E> movingNode = header.getNext();
			
			while(movingNode != trailer) {
				if(movingNode.getElement().equals(e)){
					movingNode.setElement(f);
					counter++;
				}
				movingNode = movingNode.getNext();
			}
			
			return counter;
		}


    public static int[] searchMatrix(int[][] matrix, int target) {
  
        int colums = matrix[0].length - 1;
        int rows = 0;

        while (rows < matrix.length && colums >= 0) {
            if (matrix[rows][colums] == target) {
                return new int[]{rows, colums};
            } else if (matrix[rows][colums] > target) {
            	colums--;
            } else {
                rows++;
            }
        }

        return new int[]{-1, -1};
    }


	public static int removeAfter(Node<Integer> head, int n) {
	    if (head == null) 
	        return 0; 
	    

	    int removedCount = 0;
	    Node<Integer> currentNode = head;

	    while (currentNode != null && currentNode.getNext() != null) {
	        if (currentNode.getElement().equals(n) && 
	            !currentNode.getNext().getElement().equals(n)) {

	            
	            Node<Integer> nodeToRemove = currentNode.getNext();
	            currentNode.setNext(nodeToRemove.getNext());

	            
	            nodeToRemove.clear();
	            removedCount++;
	        } else {
	            
	            currentNode = currentNode.getNext();
	        }
	    }

	    return removedCount;
	}


		public void reverse() {
			E elem1;
			int rr = this.size() -1;
			
			for(int left = 0; left < rr; left++) {
				
				elem1 = this.get(left);
				this.set(left, this.get(rr));
				this.set(rr,  elem1);
				rr--;
			}
		}

public static class DoublyLinkedList<E extends Comparable<E>> implements List<E>{
    //... [your other code inside the DoublyLinkedList class]

    public void concatenate(DoublyLinkedList<E> other) {
        if(other == null || other.isEmpty()) {
            return;
        }
        // Connect the end of the current list to the start of the other list
        this.trailer.getPrev().setNext(other.header.getNext());
        other.header.getNext().setPrev(this.trailer.getPrev());

        // Connect the end of the other list to the current trailer
        this.trailer.setPrev(other.trailer.getPrev());
        other.trailer.getPrev().setNext(this.trailer);
        
        // Update size
        this.size += other.size;
    }

    public void sort() {
        if (isEmpty()) {
            return;
        }

        Node<E> curr = header.getNext().getNext();
        while (curr != trailer) {
            Node<E> temp = curr;
            Node<E> before = curr.getPrev();
            while (before != header && temp.getElement().compareTo(before.getElement()) < 0) {
                before = before.getPrev();
            }
            // If temp needs to be moved
            if (temp.getPrev() != before) {
                // Detach temp node
                temp.getPrev().setNext(temp.getNext());
                temp.getNext().setPrev(temp.getPrev());

                // Reattach temp node after 'before' node
                temp.setNext(before.getNext());
                temp.setPrev(before);
                before.getNext().setPrev(temp);
                before.setNext(temp);
            } else {
                curr = curr.getNext();
            }
        }
    }
}

//... [rest of your code]
